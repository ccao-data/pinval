---
title: "Pin Comparison Doc"
params:
  run_id: "2025-02-11-charming-eric"
  pin1: "01282010070000"
  pin_1_card_num:
  pin2: "01013080340000"
  pin_2_card_num:
execute:
  echo: false
  warning: false
  cache: false
format:
  html:
    embed-resources: true
    grid:
      body-width: 1000px
    fig-format: svg
---

```{r load_libraries}
library(arrow)
library(ccao)
library(dplyr)
library(DT)
library(ggalt)
library(glue)
library(ggplot2)
library(ggtext)
library(leaflet)
library(noctua)
library(purrr)
library(RColorBrewer)
library(scales)
library(sf)
library(stringr)
library(tidyr)

noctua_options(cache_size = 10, unload = FALSE)

conn <- dbConnect(noctua::athena(),
  rstudio_conn_tab = FALSE
)
```


```{r setup}
# helps with NULL values for pin_x_card_num
coalesce_empty <- function(x) {
  if (is.null(x) || length(x) == 0) "" else x
}

base_cache_file_path <- glue::glue(
  "cache/{coalesce_empty(params$run_id)}_",
  "{coalesce_empty(params$pin1)}_",
  "{coalesce_empty(params$pin_1_card_num)}_",
  "{coalesce_empty(params$pin2)}_",
  "{coalesce_empty(params$pin_2_card_num)}"
)

cache_files <- list(
  char       = glue::glue("{base_cache_file_path}_char.parquet"),
  value      = glue::glue("{base_cache_file_path}_value.parquet"),
  shap       = glue::glue("{base_cache_file_path}_shap.parquet"),
  address    = glue::glue("{base_cache_file_path}_address.parquet"),
  sales      = glue::glue("{base_cache_file_path}_sales.parquet")
)

if (!dir.exists("cache")) {
  dir.create("cache", recursive = TRUE)
}

if (all(map_lgl(cache_files, file.exists))) {
  message("All cache files found. Reading from disk...")

  char <- read_parquet(cache_files$char)
  value <- read_parquet(cache_files$value)
  shap <- read_parquet(cache_files$shap)
  address <- read_parquet(cache_files$address)
  sales <- read_parquet(cache_files$sales)
} else {
  message("Some or all cache files are missing. Running queries and creating them...")

  run_id <- params$run_id
  year <- run_id %>% substr(1, 4)

  na_if_null <- function(x) {
    if (is.null(x)) NA else x
  }

  pin_labels <- data.frame(
    meta_pin = c(params$pin1, params$pin2),
    # Initial primary card should only be input if it has to be specified
    primary_card = c(na_if_null(params$pin_1_card_num), na_if_null(params$pin_2_card_num))
  )

  metadata <- dbGetQuery(
    conn,
    glue(
      "
      select
        dvc_md5_assessment_data,
        model_predictor_all_name
      from model.metadata
      where run_id = '{run_id}'
      limit 1
      "
    )
  )

  model_predictor_all_name <- metadata$model_predictor_all_name %>% unlist()
  model_predictor_all_name <- trimws(strsplit(gsub("^\\[|\\]$", "", model_predictor_all_name), ",")[[1]])

  char <- open_dataset(
    paste0(
      "s3://ccao-data-dvc-us-east-1/files/md5/",
      substr(metadata$dvc_md5_assessment_data, 1, 2), "/",
      substr(metadata$dvc_md5_assessment_data, 3, 32)
    )
  ) %>%
    filter(meta_pin %in% pin_labels$meta_pin) %>%
    collect() %>%
    select(
      meta_pin,
      meta_card_num,
      all_of(model_predictor_all_name)
    )

  pin_labels <- pin_labels %>%
    left_join(
      char %>%
        group_by(meta_pin) %>%
        summarise(total_cards = n_distinct(meta_card_num)),
      by = "meta_pin"
    )

  # Validation checks - we want card to be empty unless the parcel has more than 4 cards
  if (nrow(pin_labels %>% filter(total_cards <= 3 & !is.na(primary_card))) > 0) {
    stop("Error: For rows with total_cards <= 3, primary_card should be NA.")
  }
  if (nrow(pin_labels %>% filter(total_cards >= 4 & is.na(primary_card))) > 0) {
    stop("Error: For rows with total_cards >= 4, primary_card should have a value.")
  }

  # Add primary card for single card parcelsss
  pin_labels <- pin_labels %>%
    mutate(primary_card = if_else(total_cards == 1, 1, primary_card))

  char <- char %>%
    left_join(pin_labels %>% select(meta_pin, primary_card, total_cards), by = "meta_pin") %>%
    group_by(meta_pin) %>%
    mutate(
      max_sf = max(char_bldg_sf, na.rm = TRUE),
      target_meta = min(meta_card_num[char_bldg_sf == max_sf]),
      # If it is a 2 or 3 card property, we want to keep the max as the primary card and sum the sq footage
      is_target = total_cards %in% c(2, 3) & (char_bldg_sf == max_sf) & (meta_card_num == target_meta),
      primary_card = if_else(is_target, meta_card_num, as.character(primary_card)),
      char_bldg_sf = if_else(is_target, sum(char_bldg_sf, na.rm = TRUE), char_bldg_sf)
    ) %>%
    ungroup() %>%
    filter(primary_card == meta_card_num) %>%
    select(-c("meta_card_num", "total_cards", "is_target", "max_sf", "target_meta"))

  pin_labels <- pin_labels %>%
    left_join(
      char %>% select(meta_pin, primary_card) %>% distinct(),
      by = "meta_pin",
      suffix = c("", ".computed")
    ) %>%
    mutate(
      primary_card = as.character(primary_card),
      primary_card = coalesce(primary_card, primary_card.computed)
    ) %>%
    select(-primary_card.computed)

  value <- dbGetQuery(
    conn,
    glue_sql(
      "
      select
        card.meta_pin,
        card.meta_card_num,
        card.pred_card_initial_fmv,
        pin.pred_pin_final_fmv_round
      from model.assessment_card as card
      left join model.assessment_pin as pin
        on card.meta_pin = pin.meta_pin
        and card.meta_year = pin.meta_year
        and card.run_id = pin.run_id
      where card.run_id = {run_id}
      and card.meta_pin in ({pin_labels$meta_pin*})
      ",
      .con = conn
    )
  )

  value <- value %>%
    left_join(pin_labels, by = c("meta_pin"))

  shap <- dbGetQuery(
    conn,
    glue_sql(
      "
      select
        meta_pin,
        meta_card_num,
        {`model_predictor_all_name`*}
      from model.shap
      where run_id = {run_id}
        and meta_pin in ({pin_labels$meta_pin*})
      ",
      .con = conn
    )
  )

  shap <- shap %>%
    left_join(pin_labels, by = c("meta_pin")) %>%
    filter(primary_card == meta_card_num) %>%
    select(-c("total_cards", "primary_card", "meta_card_num")) %>%
    left_join(pin_labels %>% select(meta_pin), by = c("meta_pin")) %>%
    pivot_longer(
      cols = all_of(model_predictor_all_name),
      names_to = "Feature Name",
      values_to = "Value"
    ) %>%
    arrange(desc(meta_pin == params$pin1), desc(Value)) %>%
    pivot_wider(
      names_from = meta_pin,
      values_from = Value
    ) %>%
    mutate(`Feature Name` = factor(`Feature Name`, levels = `Feature Name`))

  address <- dbGetQuery(
    conn,
    glue_sql(
      "
      select
        pin,
        year,
        prop_address_full,
        prop_address_city_name,
        prop_address_state,
        prop_address_zipcode_1
      from default.vw_pin_address
      where pin in ({pin_labels$meta_pin*})
      and year = {year}
      ",
      .con = conn
    )
  )

  address <- address %>%
    mutate(full_address = paste(
      prop_address_full,
      prop_address_city_name,
      prop_address_state,
      prop_address_zipcode_1,
      sep = ", "
    )) %>%
    select(pin, full_address)

  sales <- dbGetQuery(
    conn,
    glue_sql(
      "
      select
        pin,
        year,
        sale_date,
        doc_no,
        sale_price,
        sv_is_outlier
      from default.vw_pin_sale
      where pin in ({pin_labels$meta_pin*})
      ",
      .con = conn
    )
  )

  comps <- dbGetQuery(
    conn,
    glue_sql(
      "
      select
        comp.pin,
        comp.comp_pin_1,
        comp.comp_pin_2,
        comp.comp_pin_3,
        comp.comp_pin_4,
        comp.comp_pin_5,
        comp.comp_pin_6,
        comp.comp_pin_7,
        comp.comp_pin_8,
        comp.comp_pin_9,
        comp.comp_pin_10,
        comp.comp_pin_11,
        comp.comp_pin_12,
        comp.comp_pin_13,
        comp.comp_pin_14,
        comp.comp_pin_15,
        comp.comp_pin_16,
        comp.comp_pin_17,
        comp.comp_pin_18,
        comp.comp_pin_19,
        comp.comp_pin_20,
        comp.comp_document_num_1,
        comp.comp_document_num_2,
        comp.comp_document_num_3,
        comp.comp_document_num_4,
        comp.comp_document_num_5,
        comp.comp_document_num_6,
        comp.comp_document_num_7,
        comp.comp_document_num_8,
        comp.comp_document_num_9,
        comp.comp_document_num_10,
        comp.comp_document_num_11,
        comp.comp_document_num_12,
        comp.comp_document_num_13,
        comp.comp_document_num_14,
        comp.comp_document_num_15,
        comp.comp_document_num_16,
        comp.comp_document_num_17,
        comp.comp_document_num_18,
        comp.comp_document_num_19,
        comp.comp_document_num_20,
        comp.comp_score_1,
        comp.comp_score_2,
        comp.comp_score_3,
        comp.comp_score_4,
        comp.comp_score_5,
        comp.comp_score_6,
        comp.comp_score_7,
        comp.comp_score_8,
        comp.comp_score_9,
        comp.comp_score_10,
        comp.comp_score_11,
        comp.comp_score_12,
        comp.comp_score_13,
        comp.comp_score_14,
        comp.comp_score_15,
        comp.comp_score_16,
        comp.comp_score_17,
        comp.comp_score_18,
        comp.comp_score_19,
        comp.comp_score_20,
        comp.card
      from model.comp as comp
      where comp.run_id = {run_id}
      and comp.pin in ({pin_labels$meta_pin*})
      ",
      .con = conn
    )
  )

  comps <- comps %>%
    left_join(pin_labels, by = c("pin" = "meta_pin")) %>%
    filter(primary_card == card) %>%
    select(-c("primary_card"))

  # Pre-extract the names of comp_pin columns from the original data frame
  comp_pin_names <- names(comps)[grepl("^comp_pin", names(comps))]

  comps <- comps %>%
    rowwise() %>%
    mutate(
      matching_index = {
        # Grab the comp_pin column and match it with PIN
        idx <- which(c_across(starts_with("comp_pin")) == pin)
        if (length(idx) > 0) idx[1] else NA_integer_
      },
      comp_score = if (!is.na(matching_index)) {
        c_across(starts_with("comp_score_"))[matching_index]
      } else {
        NA_real_
      },
      comp_number = if (!is.na(matching_index)) {
        sub("comp_pin_", "", comp_pin_names[matching_index])
      } else {
        NA_character_
      },
      # Compute the corresponding document number from the matching comp_document_num_ column
      comp_doc_no = if (!is.na(matching_index)) {
        as.character(c_across(starts_with("comp_document_num_"))[matching_index])
      } else {
        NA_character_
      }
    ) %>%
    ungroup() %>%
    mutate(
      row_id = row_number(),
      pin = as.character(pin)
    ) %>%
    rowwise() %>%
    mutate(comp_pins = list(as.character(c_across(starts_with("comp_pin"))))) %>%
    ungroup() %>%
    group_by(dummy = 1) %>%
    mutate(other_comp_pins = map(row_id, ~ {
      unique(unlist(comp_pins[row_id != .x]))
    })) %>%
    ungroup() %>%
    # Compare each pin to the corresponding other_comp_pins vector
    mutate(pin_in_other_row = map2_lgl(pin, other_comp_pins, ~ .x %in% .y))

  # Now join with sales using both pin and doc_no matching comp_doc_no
  sales <- sales %>%
    left_join(comps, by = c("pin" = "pin", "doc_no" = "comp_doc_no")) %>%
    mutate(
      sale_date = substr(sale_date, 1, 10)
    ) %>%
    select(pin, sale_date, sale_price, doc_no, comp_score, comp_number) %>%
    arrange(desc(sale_date))

  write_parquet(char, cache_files$char)
  write_parquet(value, cache_files$value)
  write_parquet(shap, cache_files$shap)
  write_parquet(address, cache_files$address)
  write_parquet(sales, cache_files$sales)
}
```

Comparison between PINs `r params$pin1` and `r params$pin2`

### Map of Parcels

```{r map}
char %>%
  left_join(address, by = c("meta_pin" = "pin")) %>%
  leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addCircleMarkers(
    lat = ~loc_latitude,
    lng = ~loc_longitude,
    popup = ~ ifelse(
      meta_pin == params$pin1,
      paste0(
        "Address: ", full_address, "<br>",
        "PIN: ",
        "<a href='https://www.cookcountyassessor.com/pin/", params$pin1,
        "' target='_blank'>", params$pin1, "</a>"
      ),
      ifelse(
        meta_pin == params$pin2,
        paste0(
          "Address: ", full_address, "<br>",
          "PIN: ",
          "<a href='", params$website2, params$pin2,
          "' target='_blank'>", params$pin2, "</a>"
        ),
        paste0("Address: ", address)
      )
    ),
    color = ~ ifelse(
      meta_pin == params$pin1, "red",
      ifelse(meta_pin == params$pin2, "blue", "green")
    ),
    radius = 5
  )
```

### Feature differences between the two parcels

Note that for parcels with 2 or 3 cards, the building square footage is summed. For the rest of the features, they are pulled from the largest of the two parcels. This coincides with our modeling techniques. For parcels with 4 or more pins, we pull the features from the target card identified in the params.

```{r feature_comparison, out.width="90%"}
char_fmt <- char %>%
  select(-primary_card) %>%
  # Convert everything to character so that we can pivot and combine feature
  # value columns
  mutate(across(everything(), as.character)) %>%
  # Pivot long so that rows are features and columns are feature values.
  # This creates two rows for each feature name, one for each PIN
  pivot_longer(
    cols = -meta_pin,
    names_to = "Feature Name",
    values_to = "Value"
  ) %>%
  # Pivot back to wide so that each property has its own column representing
  # the value for each feature. This creates one row for each feature
  pivot_wider(
    names_from = meta_pin,
    values_from = Value
  ) %>%
  # Check which feature values match across the PINs
  mutate(
    "PINs Match" = {
      params$pin1
    } == {
      params$pin2
    }
  ) %>%
  arrange(`PINs Match`)

char_fmt %>%
  datatable(
    options = list(
      paging = FALSE,
      scrollX = TRUE,
      scrollY = "400px"
    )
  ) %>%
  formatStyle(
    "PINs Match",
    backgroundColor = styleEqual(c(TRUE, FALSE), c("lightgreen", "tomato"))
  )
```

### Predicted Values

If either PIN is a multi-card, values are produced with all cards summed as well as those of the target card.

```{r predicted_values}
if (any(value$total_cards > 1, na.rm = TRUE)) {
  # Create the summary for the primary card
  summary_primary <- value %>%
    filter(primary_card == meta_card_num) %>%
    rename(
      "Initial estimate" = pred_card_initial_fmv,
      "Final rounded FMV" = pred_pin_final_fmv_round
    ) %>%
    pivot_longer(
      cols = c("Initial estimate", "Final rounded FMV"),
      names_to = "Value Type",
      values_to = "Value"
    ) %>%
    pivot_wider(
      names_from = meta_pin,
      values_from = Value
    ) %>%
    group_by(`Value Type`) %>%
    summarise(across(all_of(c(params$pin1, params$pin2)), sum, na.rm = TRUE)) %>%
    mutate(
      Difference = .data[[params$pin1]] - .data[[params$pin2]],
      Group = "Primary Card"
    )

  # Create the summary for all cards
  summary_total <- value %>%
    rename(
      "Initial estimate" = pred_card_initial_fmv,
      "Final rounded FMV" = pred_pin_final_fmv_round
    ) %>%
    pivot_longer(
      cols = c("Initial estimate", "Final rounded FMV"),
      names_to = "Value Type",
      values_to = "Value"
    ) %>%
    pivot_wider(
      names_from = meta_pin,
      values_from = Value
    ) %>%
    group_by(`Value Type`) %>%
    summarise(across(all_of(c(params$pin1, params$pin2)), sum, na.rm = TRUE)) %>%
    mutate(
      Difference = .data[[params$pin1]] - .data[[params$pin2]],
      Group = "Total"
    )

  # Bind the rows together and format the table
  final_table <- bind_rows(summary_primary, summary_total) %>%
    relocate(Group, .before = `Value Type`) %>%
    mutate(across(all_of(c(params$pin2, params$pin1, "Difference")), scales::label_currency()))
} else {
  # Only create a single (total) summary table if no value of total_cards > 1
  final_table <- value %>%
    rename(
      "Initial estimate" = pred_card_initial_fmv,
      "Final rounded FMV" = pred_pin_final_fmv_round
    ) %>%
    pivot_longer(
      cols = c("Initial estimate", "Final rounded FMV"),
      names_to = "Value Type",
      values_to = "Value"
    ) %>%
    pivot_wider(
      names_from = meta_pin,
      values_from = Value
    ) %>%
    group_by(`Value Type`) %>%
    summarise(across(all_of(c(params$pin1, params$pin2)), sum, na.rm = TRUE)) %>%
    mutate(
      Difference = .data[[params$pin1]] - .data[[params$pin2]]
    ) %>%
    mutate(across(all_of(c(params$pin2, params$pin1, "Difference")), scales::label_currency()))
}
# Formatting is outside since it doesn't render properly inside
datatable(final_table, rownames = FALSE, options = list(dom = "t"))
```

### Sale History

Each sale is marked with a checkmark if it is used as a comp sale for the reciporical pin. 

```{r sales}
sales <- sales %>%
  mutate(other_pin_is_comp = ifelse(!is.na(comp_number), "âœ…", ""))

unique_pins <- unique(sales$pin)
colors <- rainbow(length(unique_pins))

datatable_obj <- datatable(
  sales,
  options = list(order = list(list(1, "desc")))
) %>%
  formatStyle(
    "pin",
    backgroundColor = styleEqual(unique_pins, colors)
  )

datatable_obj
```

### SHAP Values

```{r SHAPs}
shap %>%
  ggplot(aes(
    y = `Feature Name`,
    x = .data[[params$pin1]],
    xend = .data[[params$pin2]]
  )) +
  geom_dumbbell(
    size_x = 1,
    size_xend = 1,
    colour_x = "red",
    colour_xend = "blue"
  ) +
  labs(
    title = "SHAP differences between the two parcels",
    x = "SHAP Value",
    y = "Feature Name"
  ) +
  theme_minimal(base_size = 5)
```

